function [valid_spikes] = ContSpkTemporal(CONdata,CONclst,SPKdata)
% ContSpkTemporal: Create a list of valid spikes (overlapping ATs) for specified
% contraction cluster.
% CONdata and SPK data must be in a specific structure as generated from
% ContractionMetrics & DataOrganiser, respectively.
% elecConfig & flipConfig are generated by RecentreElecConfigs.m
% valid_spikes has the form: 1=SPKclst, 2=meanAT, 3=meanATdiff, 4=overlap.

% Author: Sam Simmonds
% Date: 8th Novemember 2022

% Find function to gather indices of interest
CON_idx = find(CONdata(:,1) == CONclst);

% Use indices to create a list of electrodes & find mean contr starting AT
CON_AT_list = CONdata(CON_idx,3);
first_CON_AT = min(CON_AT_list); % First contractile AT
last_CON_AT = max(CON_AT_list); % Last contractile AT
CON_dur = last_CON_AT - first_CON_AT; % Contraction duration (s)
CON_AT = mean(CON_AT_list); % Mean contractile AT

% Initialise variables:
valid_spikes = [];
temp = [];
thresh = 0.5; % Time overlap threshold 0.5*SPK duration
% (At least half of the spike must be overlapping contraction)

% Loop through each spike
for i = 1:(length(SPKdata)-1)
    
    % Gather cluster and starting AT info
    cur_clst = SPKdata(i,1);
    nxt_clst = SPKdata(i+1,1);
    cur_AT = SPKdata(i,3); % grab current AT
    temp = [temp, cur_AT]; % Save to array
    
    if (cur_clst ~= nxt_clst) % If final spike in the cluster
        
        first_SPK_AT = min(temp); % First SPK AT (s)
        last_SPK_AT = max(temp); % Last SPK AT (s)
        SPK_dur = last_SPK_AT - first_SPK_AT; % Spike duration (s)
        
        overlap = min([last_SPK_AT,last_CON_AT]) - max([first_SPK_AT,first_CON_AT]);
        
        % Check mean AT diff is within threshold limits
        if (overlap >= (thresh*min([SPK_dur,CON_dur])))
            valid_spikes(end+1,:) = [cur_clst,mean(temp),mean(temp)-CON_AT,overlap];
        end
        
        temp = []; % Reset temp array
        
    elseif i == (length(SPKdata)-1) % Last entry, manually save
        
        nxt_AT = SPKdata(i+1,3); % grab next AT
        temp = [temp, nxt_AT]; % Save to array for averaging
        
        first_SPK_AT = min(temp); % First SPK AT (s)
        last_SPK_AT = max(temp); % Last SPK AT (s)
        SPK_dur = last_SPK_AT - first_SPK_AT; % Spike duration (s)
        
        overlap = min([last_SPK_AT,last_CON_AT]) - max([first_SPK_AT,first_CON_AT]);
        
        % Check mean AT diff is within threshold limits
        if (overlap >= (thresh*min([SPK_dur,CON_dur])))
            valid_spikes(end+1,:) = [cur_clst,mean(temp),mean(temp)-CON_AT,overlap];
        end
        
        temp = []; % Reset temp array
        
    end % ELSE; do nothing and continue loop
end

end

